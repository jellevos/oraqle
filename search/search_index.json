{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to oraqle","text":"A secure computation compiler <p>Simply install the most recent version of the Oraqle compiler using: <pre><code>pip install oraqle==0.1.0\n</code></pre></p> <p>Consider checking out our getting started page to help you get up to speed with arithmetizing circuits!</p>"},{"location":"#api-reference","title":"API reference","text":"<p>Warning</p> <p>In this version of Oraqle, the API is still prone to changes. Paths and names can change between any version.</p> <p>For an API reference, you can check out the pages for circuits and for nodes.</p>"},{"location":"config/","title":"Configuration parameters","text":""},{"location":"config/#oraqle.config","title":"<code>config</code>","text":"<p>This module contains global configuration options.</p> <p>Warning</p> <p>This is almost certainly going to be removed in the future.</p> <p>We do not want oraqle to have a global configuration, but this is currently an intentional evil to prevent large refactors in the initial versions.</p>"},{"location":"config/#oraqle.config.MAXSAT_TIMEOUT","title":"<code>MAXSAT_TIMEOUT = None</code>  <code>module-attribute</code>","text":"<p>Time-out for individual calls to the MaxSAT solver.</p> <p>Danger</p> <p>This causes non-deterministic behavior!</p> <p>Bug</p> <p>There is currently a chance to get <code>AttributeError</code>s, which is a bug caused by pysat trying to delete an oracle that does not exist. There is no current workaround for this.</p>"},{"location":"config/#oraqle.config.PS_METHOD_FACTOR_K","title":"<code>PS_METHOD_FACTOR_K = 2.0</code>  <code>module-attribute</code>","text":"<p>Approximation factor for the PS-method, higher is better.</p> <p>The Paterson-Stockmeyer method takes a value k, that is theoretically optimal when k = sqrt(2 * degree). However, sometimes it is better to try other values of k (e.g. due to rounding and to trade off depth and cost). This factor, let's call it f, is used to limit the candidate values of k that we try: [1, f * sqrt(2 * degree)).</p>"},{"location":"example_circuits/","title":"Example circuits","text":"<p>Warning</p> <p>Some of these example circuits are untested and may be incorrect.</p>"},{"location":"example_circuits/#oraqle.circuits","title":"<code>circuits</code>","text":"<p>This package contains example circuits and tools for generating them.</p>"},{"location":"example_circuits/#oraqle.circuits.aes","title":"<code>aes</code>","text":"<p>This module implements a high-level AES encryption circuit for a constant key.</p>"},{"location":"example_circuits/#oraqle.circuits.aes.gf","title":"<code>gf = GF(2 ** 8)</code>  <code>module-attribute</code>","text":""},{"location":"example_circuits/#oraqle.circuits.aes.circuit","title":"<code>circuit = Circuit(encrypt([Input(f'{i}', gf) for i in range(16)], b'abcdabcdabcdabcd')).arithmetize()</code>  <code>module-attribute</code>","text":""},{"location":"example_circuits/#oraqle.circuits.aes.encrypt","title":"<code>encrypt(plaintext, key)</code>","text":"<p>Returns an AES encryption circuit for a constant <code>key</code>.</p>"},{"location":"example_circuits/#oraqle.circuits.aes.test_aes_128","title":"<code>test_aes_128()</code>","text":""},{"location":"example_circuits/#oraqle.circuits.cardio","title":"<code>cardio</code>","text":"<p>This module implements the cardio circuit that is often used in benchmarking compilers, see: https://arxiv.org/abs/2101.07078.</p>"},{"location":"example_circuits/#oraqle.circuits.cardio.construct_cardio_risk_circuit","title":"<code>construct_cardio_risk_circuit(gf)</code>","text":"<p>Returns the cardio circuit from https://arxiv.org/abs/2101.07078.</p>"},{"location":"example_circuits/#oraqle.circuits.cardio.construct_cardio_elevated_risk_circuit","title":"<code>construct_cardio_elevated_risk_circuit(gf)</code>","text":"<p>Returns a variant of the cardio circuit that returns a Boolean indicating whether any risk factor returned true.</p>"},{"location":"example_circuits/#oraqle.circuits.cardio.test_cardio_p101","title":"<code>test_cardio_p101()</code>","text":""},{"location":"example_circuits/#oraqle.circuits.median","title":"<code>median</code>","text":"<p>This module implements circuits for computing the median.</p>"},{"location":"example_circuits/#oraqle.circuits.median.gf","title":"<code>gf = GF(1037347783)</code>  <code>module-attribute</code>","text":""},{"location":"example_circuits/#oraqle.circuits.median.circuit","title":"<code>circuit = gen_median_circuit(range(10), gf)</code>  <code>module-attribute</code>","text":""},{"location":"example_circuits/#oraqle.circuits.median.gen_median_circuit","title":"<code>gen_median_circuit(inputs, gf)</code>","text":"<p>Returns a naive circuit for finding the median value of <code>inputs</code>.</p>"},{"location":"example_circuits/#oraqle.circuits.mimc","title":"<code>mimc</code>","text":"<p>MIMC is an MPC-friendly cipher: https://eprint.iacr.org/2016/492.</p>"},{"location":"example_circuits/#oraqle.circuits.mimc.gf","title":"<code>gf = GF(680564733841876926926749214863536422929)</code>  <code>module-attribute</code>","text":""},{"location":"example_circuits/#oraqle.circuits.mimc.node","title":"<code>node = encrypt(Input('m', gf), 12345)</code>  <code>module-attribute</code>","text":""},{"location":"example_circuits/#oraqle.circuits.mimc.circuit","title":"<code>circuit = Circuit([node]).arithmetize()</code>  <code>module-attribute</code>","text":""},{"location":"example_circuits/#oraqle.circuits.mimc.encrypt","title":"<code>encrypt(plaintext, key, power_n=129)</code>","text":"<p>Returns an MIMC encryption circuit using a constant key.</p>"},{"location":"example_circuits/#oraqle.circuits.mimc.test_mimc_129","title":"<code>test_mimc_129()</code>","text":""},{"location":"example_circuits/#oraqle.circuits.sorting","title":"<code>sorting</code>","text":"<p>This module contains sorting circuits and comparators.</p>"},{"location":"example_circuits/#oraqle.circuits.sorting.gf","title":"<code>gf = GF(13)</code>  <code>module-attribute</code>","text":""},{"location":"example_circuits/#oraqle.circuits.sorting.circuit","title":"<code>circuit = gen_naive_sort_circuit(range(2), gf)</code>  <code>module-attribute</code>","text":""},{"location":"example_circuits/#oraqle.circuits.sorting.cswp","title":"<code>cswp(lhs, rhs)</code>","text":"<p>Conditionally swap inputs <code>lhs</code> and <code>rhs</code> such that <code>lhs &lt;= rhs</code>.</p> <p>Returns:</p> <ul> <li> <code>Tuple[Node, Node]</code>           \u2013            <p>A tuple representing (lower, higher)</p> </li> </ul>"},{"location":"example_circuits/#oraqle.circuits.sorting.gen_naive_sort_circuit","title":"<code>gen_naive_sort_circuit(inputs, gf)</code>","text":"<p>Returns a naive sorting circuit for the given sequence of <code>inputs</code>.</p>"},{"location":"example_circuits/#oraqle.circuits.veto_voting","title":"<code>veto_voting</code>","text":"<p>The veto voting circuit is the inverse of a consensus vote between a number of participants.</p> <p>The circuit is essentially a large OR operation, returning 1 if any participant vetoes (by submitting a 1). This represents a vote that anyone can veto.</p>"},{"location":"example_circuits/#oraqle.circuits.veto_voting.gf","title":"<code>gf = GF(103)</code>  <code>module-attribute</code>","text":""},{"location":"example_circuits/#oraqle.circuits.veto_voting.circuit","title":"<code>circuit = gen_veto_voting_circuit(10, gf).arithmetize()</code>  <code>module-attribute</code>","text":""},{"location":"example_circuits/#oraqle.circuits.veto_voting.gen_veto_voting_circuit","title":"<code>gen_veto_voting_circuit(participants, gf)</code>","text":"<p>Returns a veto voting circuit between the number of <code>participants</code>.</p>"},{"location":"getting_started/","title":"Getting started","text":"<p>In 5 minutes, this page will guide you through how to install oraqle, how to specify high-level programs, and how to arithmetize your first circuit!</p>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>Simply install the most recent version of the Oraqle compiler using: <pre><code>pip install oraqle\n</code></pre></p> <p>We use continuous integration to test every build of the Oraqle compiler on Windows, MacOS, and Unix systems. If you do run into problems, feel free to open an issue on GitHub!</p>"},{"location":"getting_started/#specifying-high-level-programs","title":"Specifying high-level programs","text":"<p>Let's start with importing <code>galois</code>, which represents our plaintext algebra. We will also immediately import the relevant oraqle classes for our little example: <pre><code>from galois import GF\n\nfrom oraqle.compiler.circuit import Circuit\nfrom oraqle.compiler.nodes.leafs import Input\n</code></pre></p> <p>For this example, we will use 31 as our plaintext modulus. This algebra is denoted by <code>GF(31)</code>. Let's create a few inputs that represent elements in this algebra: <pre><code>gf = GF(31)\n\nx = Input(\"x\", gf)\ny = Input(\"y\", gf)\nz = Input(\"z\", gf)\n</code></pre></p> <p>We can now perform some operations on these elements, and they do not have to be arithmetic operations! For example, we can perform equality checks or comparisons: <pre><code>comparison = x &lt; y\nequality = y == z\nboth = comparison &amp; equality\n</code></pre></p> <p>While we have specified some operations, we have not yet established this as a circuit. We will do so now: <pre><code>circuit = Circuit([both])\n</code></pre></p> <p>And that's it! We are done specifying our first high-level circuit. As you can see this is all very similar to writing a regular Python program. If you want to visualize this high-level circuit before we continue with arithmetizing it, you can run the following (if you have graphviz installed): <pre><code>circuit.to_pdf(\"high_level_circuit.pdf\")\n</code></pre></p> <p>Tip</p> <p>If you do not have graphviz installed, you can instead call: <pre><code>circuit.to_dot(\"high_level_circuit.dot\")\n</code></pre> After that, you can copy the file contents to an online graphviz viewer!</p>"},{"location":"getting_started/#arithmetizing-your-first-circuit","title":"Arithmetizing your first circuit","text":"<p>At this point, arithmetization is a breeze, because the oraqle compiler takes care of these steps. We can create an arithmetic circuit and visualize it using the following snippet: <pre><code>arithmetic_circuit = circuit.arithmetize()\narithmetic_circuit.to_pdf(\"arithmetic_circuit.pdf\")\n</code></pre></p> <p>You will notice that it's quite a large circuit. But how large is it exactly? This is a question that we can ask to the oraqle compiler: <pre><code>print(\"Depth:\", arithmetic_circuit.multiplicative_depth())\nprint(\"Size:\", arithmetic_circuit.multiplicative_size())\nprint(\"Cost:\", arithmetic_circuit.multiplicative_cost(0.7))\n</code></pre></p> <p>In the last line, we asked the compiler to output the multiplicative cost, considering that squaring operations are cheaper than regular multiplications. We weighed this cost with a factor 0.7.</p> <p>Now that we have an arithmetic circuit, we can use homomorphic encryption to evaluate it! If you are curious about executing these circuits for real, consider reading the code generation tutorial.</p> <p>Warning</p> <p>There are many homomorphic encryption libraries that do not support plaintext moduli that are not NTT-friendly. The plaintext modulus we chose (31) is not NTT-friendly. In fact, only very few primes are NTT-friendly, and they are somewhat large. This is why, right now, the oraqle compiler only implements code generation for HElib. HElib is (as far as we are aware) the only library that supports plaintext moduli that are not NTT-friendly.</p>"},{"location":"tutorial_running_exps/","title":"Tutorial: Running experiments","text":"<p>Failure</p> <p>This section is currently missing. Please see the code generation API for some documentation for now.</p>"},{"location":"api/abstract_nodes_api/","title":"Abstract nodes API","text":"<p>Warning</p> <p>In this version of Oraqle, the API is still prone to changes. Paths and names can change between any version.</p> <p>If you want to extend the oraqle compiler, or implement your own high-level nodes, it is easiest to extend one of the existing abstract node classes.</p>"},{"location":"api/addition_chains_api/","title":"Addition chains API","text":"<p>Warning</p> <p>In this version of Oraqle, the API is still prone to changes. Paths and names can change between any version.</p> <p>The <code>add_chains</code> module contains tools for generating addition chains.</p>"},{"location":"api/addition_chains_api/#oraqle.add_chains","title":"<code>add_chains</code>","text":"<p>Tools for generating addition chains using different constraints and objectives.</p>"},{"location":"api/addition_chains_api/#oraqle.add_chains.addition_chains","title":"<code>addition_chains</code>","text":"<p>Tools for generating short addition chains using a MaxSAT formulation.</p>"},{"location":"api/addition_chains_api/#oraqle.add_chains.addition_chains.thurber_bounds","title":"<code>thurber_bounds(target, max_size)</code>","text":"<p>Returns the Thurber bounds for a given target and a maximum size of the addition chain.</p>"},{"location":"api/addition_chains_api/#oraqle.add_chains.addition_chains.add_chain","title":"<code>add_chain(target, max_depth, strict_cost_max, squaring_cost, solver, encoding, thurber, min_size, precomputed_values)</code>","text":"<p>Generates a minimum-cost addition chain for a given target, abiding to the constraints.</p> <p>Parameters:</p> <ul> <li> <code>target</code>               (<code>int</code>)           \u2013            <p>The target integer.</p> </li> <li> <code>max_depth</code>               (<code>Optional[int]</code>)           \u2013            <p>The maximum depth of the addition chain</p> </li> <li> <code>strict_cost_max</code>               (<code>float</code>)           \u2013            <p>A strict upper bound on the cost of the addition chain. I.e., cost(chain) &lt; strict_cost_max.</p> </li> <li> <code>squaring_cost</code>               (<code>float</code>)           \u2013            <p>The cost of doubling (squaring), compared to other additions (multiplications), which cost 1.0.</p> </li> <li> <code>solver</code>               (<code>str</code>)           \u2013            <p>Name of the SAT solver, e.g. \"glucose421\" for glucose 4.2.1. See: https://pysathq.github.io/docs/html/api/solvers.html.</p> </li> <li> <code>encoding</code>               (<code>int</code>)           \u2013            <p>The encoding to use for cardinality constraints. See: https://pysathq.github.io/docs/html/api/card.html#pysat.card.EncType.</p> </li> <li> <code>thurber</code>               (<code>bool</code>)           \u2013            <p>Whether to use the Thurber bounds, which provide lower bounds for the elements in the chain. The bounds are ignored when <code>precomputed_values = True</code>.</p> </li> <li> <code>min_size</code>               (<code>int</code>)           \u2013            <p>The minimum size of the chain. It is always possible to use <code>math.ceil(math.log2(target))</code>.</p> </li> <li> <code>precomputed_values</code>               (<code>Optional[Tuple[Tuple[int, int], ...]]</code>)           \u2013            <p>If there are any precomputed values that can be used for free, they can be specified as a tuple of pairs (value, chain_depth).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TimeoutError</code>             \u2013            <p>If the global MAXSAT_TIMEOUT is not None, and it is reached before a maxsat instance could be solved.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[List[Tuple[int, int]]]</code>           \u2013            <p>A minimum-cost addition chain, if it exists.</p> </li> </ul>"},{"location":"api/addition_chains_api/#oraqle.add_chains.addition_chains_front","title":"<code>addition_chains_front</code>","text":"<p>Tools for generating addition chains that trade off depth and cost.</p>"},{"location":"api/addition_chains_api/#oraqle.add_chains.addition_chains_front.chain_depth","title":"<code>chain_depth(chain, precomputed_values=None, modulus=None)</code>","text":"<p>Return the depth of the addition chain.</p>"},{"location":"api/addition_chains_api/#oraqle.add_chains.addition_chains_front.gen_pareto_front","title":"<code>gen_pareto_front(target, modulus, squaring_cost, solver='glucose42', encoding=1, thurber=True, precomputed_values=None)</code>","text":"<p>Returns a Pareto front of addition chains, trading of cost and depth.</p>"},{"location":"api/addition_chains_api/#oraqle.add_chains.addition_chains_heuristic","title":"<code>addition_chains_heuristic</code>","text":"<p>This module contains functions for finding addition chains, while sometimes resorting to heuristics to prevent long computations.</p>"},{"location":"api/addition_chains_api/#oraqle.add_chains.addition_chains_heuristic.add_chain_guaranteed","title":"<code>add_chain_guaranteed(target, modulus, squaring_cost, solver='glucose421', encoding=1, thurber=True, precomputed_values=None)</code>  <code>cached</code>","text":"<p>Always generates an addition chain for a given target, which is suboptimal if the inputs are too large.</p> <p>In some cases, the result is not necessarily optimal. These are the cases where we resort to a heuristic. This currently happens if: - The target exceeds 1000. - The modulus (if provided) exceeds 200. - MAXSAT_TIMEOUT is not None and a MaxSAT instance timed out</p> <p>Note</p> <p>This function is useful for preventing long computation, but the result is not guaranteed to be (close to) optimal. Unlike <code>add_chain</code>, this function will always return an addition chain.</p> <p>Parameters:</p> <ul> <li> <code>target</code>               (<code>int</code>)           \u2013            <p>The target integer.</p> </li> <li> <code>modulus</code>               (<code>Optional[int]</code>)           \u2013            <p>Modulus to take into account. In an exponentiation chain, this is the modulus in the exponent, i.e. x^target mod p corresponds to <code>modulus = p - 1</code>.</p> </li> <li> <code>squaring_cost</code>               (<code>float</code>)           \u2013            <p>The cost of doubling (squaring), compared to other additions (multiplications), which cost 1.0.</p> </li> <li> <code>solver</code>               (<code>str</code>, default:                   <code>'glucose421'</code> )           \u2013            <p>Name of the SAT solver, e.g. \"glucose421\" for glucose 4.2.1. See: https://pysathq.github.io/docs/html/api/solvers.html.</p> </li> <li> <code>encoding</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The encoding to use for cardinality constraints. See: https://pysathq.github.io/docs/html/api/card.html#pysat.card.EncType.</p> </li> <li> <code>thurber</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to use the Thurber bounds, which provide lower bounds for the elements in the chain. The bounds are ignored when <code>precomputed_values = True</code>.</p> </li> <li> <code>precomputed_values</code>               (<code>Optional[Tuple[Tuple[int, int], ...]]</code>, default:                   <code>None</code> )           \u2013            <p>If there are any precomputed values that can be used for free, they can be specified as a tuple of pairs (value, chain_depth).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TimeoutError</code>             \u2013            <p>If the global MAXSAT_TIMEOUT is not None, and it is reached before a maxsat instance could be solved.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Tuple[int, int]]</code>           \u2013            <p>An addition chain.</p> </li> </ul>"},{"location":"api/addition_chains_api/#oraqle.add_chains.addition_chains_mod","title":"<code>addition_chains_mod</code>","text":"<p>Tools for computing addition chains, taking into account the modular nature of the algebra.</p>"},{"location":"api/addition_chains_api/#oraqle.add_chains.addition_chains_mod.hw","title":"<code>hw(n)</code>","text":"<p>Returns the Hamming weight of n.</p>"},{"location":"api/addition_chains_api/#oraqle.add_chains.addition_chains_mod.size_lower_bound","title":"<code>size_lower_bound(target)</code>","text":"<p>Returns a lower bound on the size of the addition chain for this target.</p>"},{"location":"api/addition_chains_api/#oraqle.add_chains.addition_chains_mod.cost_lower_bound_monotonic","title":"<code>cost_lower_bound_monotonic(target, squaring_cost)</code>","text":"<p>Returns a lower bound on the cost of the addition chain for this target. The bound is guaranteed to grow monotonically with the target.</p>"},{"location":"api/addition_chains_api/#oraqle.add_chains.addition_chains_mod.chain_cost","title":"<code>chain_cost(chain, squaring_cost)</code>","text":"<p>Returns the cost of the addition chain, considering doubling (squaring) to be cheaper than other additions (multiplications).</p>"},{"location":"api/addition_chains_api/#oraqle.add_chains.addition_chains_mod.add_chain_modp","title":"<code>add_chain_modp(target, modulus, max_depth, strict_cost_max, squaring_cost, solver, encoding, thurber, min_size, precomputed_values=None)</code>","text":"<p>Computes an addition chain for target modulo p with the given constraints and optimization parameters.</p> <p>The precomputed_powers are an optional set of powers that have previously been computed along with their depth. This means that those powers can be reused for free.</p> <p>Returns:</p> <ul> <li> <code>Optional[List[Tuple[int, int]]]</code>           \u2013            <p>If it exists, a minimal addition chain meeting the given constraints and optimization parameters.</p> </li> </ul>"},{"location":"api/addition_chains_api/#oraqle.add_chains.memoization","title":"<code>memoization</code>","text":"<p>This module contains tools for memoizing addition chains, as these are expensive to compute.</p>"},{"location":"api/addition_chains_api/#oraqle.add_chains.memoization.cache_to_disk","title":"<code>cache_to_disk(ignore_args)</code>","text":"<p>This decorator caches the calls to this function in a file on disk, ignoring the arguments listed in <code>ignore_args</code>.</p> <p>Returns:</p> <ul> <li>           \u2013            <p>A cached output</p> </li> </ul>"},{"location":"api/addition_chains_api/#oraqle.add_chains.solving","title":"<code>solving</code>","text":"<p>Tools for solving SAT formulations.</p>"},{"location":"api/addition_chains_api/#oraqle.add_chains.solving.solve","title":"<code>solve(wcnf, solver, strict_cost_max)</code>","text":"<p>This code is adapted from pysat's internal code to stop when we have reached a maximum cost.</p> <p>Returns:</p> <ul> <li> <code>Optional[List[int]]</code>           \u2013            <p>A list containing the assignment (where 3 indicates that 3=True and -3 indicates that 3=False), or None if the wcnf is unsatisfiable.</p> </li> </ul>"},{"location":"api/addition_chains_api/#oraqle.add_chains.solving.extract_indices","title":"<code>extract_indices(sequence, precomputed_values=None, modulus=None)</code>","text":"<p>Returns the indices for each step of the addition chain.</p> <p>If n precomputed values are provided, then these are considered to be the first n indices after x (i.e. x has index 0, followed by 1, ..., n representing the precomputed values).</p>"},{"location":"api/addition_chains_api/#oraqle.add_chains.solving.solve_with_time_limit","title":"<code>solve_with_time_limit(wcnf, solver, strict_cost_max, timeout_secs)</code>","text":"<p>This code is adapted from pysat's internal code to stop when we have reached a maximum cost.</p> <p>Raises:</p> <ul> <li> <code>TimeoutError</code>             \u2013            <p>When a timeout occurs (after <code>timeout_secs</code> seconds)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[List[int]]</code>           \u2013            <p>A list containing the assignment (where 3 indicates that 3=True and -3 indicates that 3=False), or None if the wcnf is unsatisfiable.</p> </li> </ul>"},{"location":"api/circuits_api/","title":"Circuits API","text":"<p>Warning</p> <p>In this version of Oraqle, the API is still prone to changes. Paths and names can change between any version.</p>"},{"location":"api/circuits_api/#high-level-circuits","title":"High-level circuits","text":""},{"location":"api/circuits_api/#oraqle.compiler.circuit.Circuit","title":"<code>Circuit</code>","text":"<p>Represents a circuit over a fixed finite field that can be turned into an arithmetic circuit. Behind the scenes this is a directed acyclic graph (DAG). The circuit only has references to the outputs.</p>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.Circuit.__init__","title":"<code>__init__(outputs)</code>","text":"<p>Initialize a circuit with the given <code>outputs</code>.</p>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.Circuit.evaluate","title":"<code>evaluate(actual_inputs)</code>","text":"<p>Evaluates the circuit with the given named inputs.</p> <p>This function does not error if it is given more inputs than necessary, but it will error if one is missing.</p> <p>Returns:</p> <ul> <li> <code>List[FieldArray]</code>           \u2013            <p>Evaluated output in plain text.</p> </li> </ul>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.Circuit.to_graph","title":"<code>to_graph(file_name)</code>","text":"<p>Saves a DOT file representing the circuit as a graph at the given <code>file_name</code>.</p>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.Circuit.to_pdf","title":"<code>to_pdf(file_name)</code>","text":"<p>Saves a PDF file representing the circuit as a graph at the given <code>file_name</code>.</p>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.Circuit.to_svg","title":"<code>to_svg(file_name)</code>","text":"<p>Saves an SVG file representing the circuit as a graph at the given <code>file_name</code>.</p>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.Circuit.display_graph","title":"<code>display_graph(metadata=None)</code>","text":"<p>Displays the circuit in a Python notebook.</p>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.Circuit.eliminate_subexpressions","title":"<code>eliminate_subexpressions()</code>","text":"<p>Perform semantic common subexpression elimination on all outputs.</p>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.Circuit.is_equivalent","title":"<code>is_equivalent(other)</code>","text":"<p>Returns whether the two circuits are semantically equivalent.</p> <p>False positives do not occure but false negatives do.</p>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.Circuit.arithmetize","title":"<code>arithmetize(strategy='best-effort')</code>","text":"<p>Arithmetizes this circuit by calling arithmetize on all outputs.</p> <p>This replaces all high-level operations with arithmetic operations (constants, additions, and multiplications). The current implementation only aims at reducing the total number of multiplications.</p> <p>Returns:</p> <ul> <li> <code>ArithmeticCircuit</code>           \u2013            <p>An equivalent arithmetic circuit with low multiplicative size.</p> </li> </ul>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.Circuit.arithmetize_depth_aware","title":"<code>arithmetize_depth_aware(cost_of_squaring=1.0)</code>","text":"<p>Perform depth-aware arithmetization on this circuit.</p> <p>Failure</p> <p>The current implementation only supports circuits with a single output.</p> <p>This function replaces high-level nodes with arithmetic operations (constants, additions, and multiplications).</p> <p>Returns:</p> <ul> <li> <code>List[Tuple[int, int, ArithmeticCircuit]]</code>           \u2013            <p>A list with tuples containing the multiplicative depth, the multiplicative cost, and the generated arithmetization from low to high depth.</p> </li> </ul>"},{"location":"api/circuits_api/#arithmetic-circuits","title":"Arithmetic circuits","text":""},{"location":"api/circuits_api/#oraqle.compiler.circuit.ArithmeticCircuit","title":"<code>ArithmeticCircuit</code>","text":"<p>               Bases: <code>Circuit</code></p> <p>Represents an arithmetic circuit over a fixed finite field, so it only contains arithmetic nodes.</p>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.ArithmeticCircuit.__init__","title":"<code>__init__(outputs)</code>","text":"<p>Initialize a circuit with the given <code>outputs</code>.</p>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.ArithmeticCircuit.evaluate","title":"<code>evaluate(actual_inputs)</code>","text":"<p>Evaluates the circuit with the given named inputs.</p> <p>This function does not error if it is given more inputs than necessary, but it will error if one is missing.</p> <p>Returns:</p> <ul> <li> <code>List[FieldArray]</code>           \u2013            <p>Evaluated output in plain text.</p> </li> </ul>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.ArithmeticCircuit.to_graph","title":"<code>to_graph(file_name)</code>","text":"<p>Saves a DOT file representing the circuit as a graph at the given <code>file_name</code>.</p>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.ArithmeticCircuit.to_pdf","title":"<code>to_pdf(file_name)</code>","text":"<p>Saves a PDF file representing the circuit as a graph at the given <code>file_name</code>.</p>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.ArithmeticCircuit.to_svg","title":"<code>to_svg(file_name)</code>","text":"<p>Saves an SVG file representing the circuit as a graph at the given <code>file_name</code>.</p>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.ArithmeticCircuit.display_graph","title":"<code>display_graph(metadata=None)</code>","text":"<p>Displays the circuit in a Python notebook.</p>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.ArithmeticCircuit.eliminate_subexpressions","title":"<code>eliminate_subexpressions()</code>","text":"<p>Perform semantic common subexpression elimination on all outputs.</p>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.ArithmeticCircuit.is_equivalent","title":"<code>is_equivalent(other)</code>","text":"<p>Returns whether the two circuits are semantically equivalent.</p> <p>False positives do not occure but false negatives do.</p>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.ArithmeticCircuit.arithmetize","title":"<code>arithmetize(strategy='best-effort')</code>","text":"<p>Arithmetizes this circuit by calling arithmetize on all outputs.</p> <p>This replaces all high-level operations with arithmetic operations (constants, additions, and multiplications). The current implementation only aims at reducing the total number of multiplications.</p> <p>Returns:</p> <ul> <li> <code>ArithmeticCircuit</code>           \u2013            <p>An equivalent arithmetic circuit with low multiplicative size.</p> </li> </ul>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.ArithmeticCircuit.arithmetize_depth_aware","title":"<code>arithmetize_depth_aware(cost_of_squaring=1.0)</code>","text":"<p>Perform depth-aware arithmetization on this circuit.</p> <p>Failure</p> <p>The current implementation only supports circuits with a single output.</p> <p>This function replaces high-level nodes with arithmetic operations (constants, additions, and multiplications).</p> <p>Returns:</p> <ul> <li> <code>List[Tuple[int, int, ArithmeticCircuit]]</code>           \u2013            <p>A list with tuples containing the multiplicative depth, the multiplicative cost, and the generated arithmetization from low to high depth.</p> </li> </ul>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.ArithmeticCircuit.multiplicative_depth","title":"<code>multiplicative_depth()</code>","text":"<p>Returns the multiplicative depth of the circuit.</p>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.ArithmeticCircuit.multiplicative_size","title":"<code>multiplicative_size()</code>","text":"<p>Returns the multiplicative size (number of multiplications) of the circuit.</p>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.ArithmeticCircuit.multiplicative_cost","title":"<code>multiplicative_cost(cost_of_squaring)</code>","text":"<p>Returns the multiplicative cost of the circuit.</p>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.ArithmeticCircuit.generate_program","title":"<code>generate_program()</code>","text":"<p>Returns an arithmetic program for this arithmetic circuit.</p>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.ArithmeticCircuit.summands_between_multiplications","title":"<code>summands_between_multiplications()</code>","text":"<p>Computes the maximum number of summands between two consecutive multiplications in this circuit.</p> <p>Failure</p> <p>This currently returns the hardcoded value 10</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The highest number of summands between two consecutive multiplications</p> </li> </ul>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.ArithmeticCircuit.generate_code","title":"<code>generate_code(filename, iterations=1, measure_time=False, decrypt_outputs=False)</code>","text":"<p>Generates an HElib implementation of the circuit.</p> <p>If decrypt_outputs is True, prints the decrypted output. Otherwise, it prints whether the ciphertext has noise budget remaining (i.e. it is correct with high probability).</p> <p>Note</p> <p>Decryption is part of the measured run time.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>Test</p> </li> <li> <code>iterations</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of times to run the circuit</p> </li> <li> <code>measure_time</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to output a measurement of the total run time</p> </li> <li> <code>decrypt_outputs</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to print the decrypted outputs, or to simply check if there is noise budget remaining</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[int, int, int, int]</code>           \u2013            <p>Parameters that were chosen: (ring dimension m, Hensel lifting = 1, bits in the modchain, columns in key switching = 3).</p> </li> </ul>"},{"location":"api/circuits_api/#oraqle.compiler.circuit.ArithmeticCircuit.run_using_helib","title":"<code>run_using_helib(iterations, measure_time=False, decrypt_outputs=False, **kwargs)</code>","text":"<p>Generate a program using HElib and execute it, measuring the average run time.</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If an error occured during the build or execution.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Average run time in seconds as a float</p> </li> </ul>"},{"location":"api/code_generation_api/","title":"Code generation API","text":"<p>Warning</p> <p>In this version of Oraqle, the API is still prone to changes. Paths and names can change between any version.</p> <p>The easiest way is using: <pre><code>arithmetic_circuit.generate_code()\n</code></pre></p>"},{"location":"api/code_generation_api/#arithmetic-instructions","title":"Arithmetic instructions","text":"<p>If you want to extend the oraqle compiler, or implement your own code generation, you can use the following instructions to do so.</p> Abstract instruction InputInstruction AdditionInstruction MultiplicationInstruction ConstantAdditionInstruction ConstantMultiplicationInstruction OutputInstruction"},{"location":"api/code_generation_api/#oraqle.compiler.instructions.ArithmeticInstruction","title":"<code>ArithmeticInstruction</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract arithmetic instruction that computes an operation in an arithmetic circuit using a stack.</p>"},{"location":"api/code_generation_api/#oraqle.compiler.instructions.ArithmeticInstruction.__init__","title":"<code>__init__(stack_index)</code>","text":"<p>Initialize an instruction that writes it output to the stack at <code>stack_index</code>.</p>"},{"location":"api/code_generation_api/#oraqle.compiler.instructions.ArithmeticInstruction.evaluate","title":"<code>evaluate(stack, inputs)</code>  <code>abstractmethod</code>","text":"<p>Executes the instruction on plaintext inputs without using encryption, keeping track of the plaintext values in the stack.</p>"},{"location":"api/code_generation_api/#oraqle.compiler.instructions.ArithmeticInstruction.generate_code","title":"<code>generate_code(stack_initialized, decrypt_outputs)</code>  <code>abstractmethod</code>","text":"<p>Generates code for this instruction, keeping track of which places of the stack are already initialized.</p>"},{"location":"api/code_generation_api/#oraqle.compiler.instructions.InputInstruction","title":"<code>InputInstruction</code>","text":"<p>               Bases: <code>ArithmeticInstruction</code></p> <p>Writes an input to the stack.</p>"},{"location":"api/code_generation_api/#oraqle.compiler.instructions.InputInstruction.__init__","title":"<code>__init__(stack_index, name)</code>","text":"<p>Initialize an <code>InputInstruction</code> that places the input with the given <code>name</code> in the stack at index <code>stack_index</code>.</p>"},{"location":"api/code_generation_api/#oraqle.compiler.instructions.InputInstruction.evaluate","title":"<code>evaluate(stack, inputs)</code>","text":""},{"location":"api/code_generation_api/#oraqle.compiler.instructions.InputInstruction.generate_code","title":"<code>generate_code(stack_initialized, _decrypt_outputs)</code>","text":""},{"location":"api/code_generation_api/#oraqle.compiler.instructions.AdditionInstruction","title":"<code>AdditionInstruction</code>","text":"<p>               Bases: <code>ArithmeticInstruction</code></p> <p>Reads two elements from the stack, adds them, and writes the result to the stack.</p>"},{"location":"api/code_generation_api/#oraqle.compiler.instructions.AdditionInstruction.__init__","title":"<code>__init__(stack_index, left_stack_index, right_stack_index)</code>","text":"<p>Initialize an instruction that adds the elements at <code>left_stack_index</code> and <code>right_stack_index</code>, placing the result at <code>stack_index</code>.</p>"},{"location":"api/code_generation_api/#oraqle.compiler.instructions.AdditionInstruction.evaluate","title":"<code>evaluate(stack, _inputs)</code>","text":""},{"location":"api/code_generation_api/#oraqle.compiler.instructions.AdditionInstruction.generate_code","title":"<code>generate_code(stack_initialized, _decrypt_outputs)</code>","text":""},{"location":"api/code_generation_api/#oraqle.compiler.instructions.MultiplicationInstruction","title":"<code>MultiplicationInstruction</code>","text":"<p>               Bases: <code>ArithmeticInstruction</code></p> <p>Reads two elements from the stack, multiplies them, and writes the result to the stack.</p>"},{"location":"api/code_generation_api/#oraqle.compiler.instructions.MultiplicationInstruction.__init__","title":"<code>__init__(stack_index, left_stack_index, right_stack_index)</code>","text":"<p>Initialize an instruction that multiplies the elements at <code>left_stack_index</code> and <code>right_stack_index</code>, placing the result at <code>stack_index</code>.</p>"},{"location":"api/code_generation_api/#oraqle.compiler.instructions.MultiplicationInstruction.evaluate","title":"<code>evaluate(stack, _inputs)</code>","text":""},{"location":"api/code_generation_api/#oraqle.compiler.instructions.MultiplicationInstruction.generate_code","title":"<code>generate_code(stack_initialized, _decrypt_outputs)</code>","text":""},{"location":"api/code_generation_api/#oraqle.compiler.instructions.ConstantAdditionInstruction","title":"<code>ConstantAdditionInstruction</code>","text":"<p>               Bases: <code>ArithmeticInstruction</code></p> <p>Reads an element from the stack, adds a constant to it it, and writes the result to the stack.</p>"},{"location":"api/code_generation_api/#oraqle.compiler.instructions.ConstantAdditionInstruction.__init__","title":"<code>__init__(stack_index, input_stack_index, constant)</code>","text":"<p>Initialize an instruction that adds <code>constant</code> to the element at <code>input_stack_index</code>, placing the result at <code>stack_index</code>.</p>"},{"location":"api/code_generation_api/#oraqle.compiler.instructions.ConstantAdditionInstruction.evaluate","title":"<code>evaluate(stack, _inputs)</code>","text":""},{"location":"api/code_generation_api/#oraqle.compiler.instructions.ConstantAdditionInstruction.generate_code","title":"<code>generate_code(stack_initialized, _decrypt_outputs)</code>","text":""},{"location":"api/code_generation_api/#oraqle.compiler.instructions.ConstantMultiplicationInstruction","title":"<code>ConstantMultiplicationInstruction</code>","text":"<p>               Bases: <code>ArithmeticInstruction</code></p> <p>Reads an element from the stack, multiplies it with a constant, and writes the result to the stack.</p>"},{"location":"api/code_generation_api/#oraqle.compiler.instructions.ConstantMultiplicationInstruction.__init__","title":"<code>__init__(stack_index, input_stack_index, constant)</code>","text":"<p>Initialize an instruction that multiplies the element at <code>input_stack_index</code> with <code>constant</code>, placing the result at <code>stack_index</code>.</p>"},{"location":"api/code_generation_api/#oraqle.compiler.instructions.ConstantMultiplicationInstruction.evaluate","title":"<code>evaluate(stack, _inputs)</code>","text":""},{"location":"api/code_generation_api/#oraqle.compiler.instructions.ConstantMultiplicationInstruction.generate_code","title":"<code>generate_code(stack_initialized, _decrypt_outputs)</code>","text":""},{"location":"api/code_generation_api/#oraqle.compiler.instructions.OutputInstruction","title":"<code>OutputInstruction</code>","text":"<p>               Bases: <code>ArithmeticInstruction</code></p> <p>Outputs an element from the stack.</p>"},{"location":"api/code_generation_api/#oraqle.compiler.instructions.OutputInstruction.__init__","title":"<code>__init__(stack_index)</code>","text":"<p>Initialize an instruction that writes it output to the stack at <code>stack_index</code>.</p>"},{"location":"api/code_generation_api/#oraqle.compiler.instructions.OutputInstruction.evaluate","title":"<code>evaluate(stack, _inputs)</code>","text":""},{"location":"api/code_generation_api/#oraqle.compiler.instructions.OutputInstruction.generate_code","title":"<code>generate_code(stack_initialized, decrypt_outputs)</code>","text":""},{"location":"api/code_generation_api/#generating-arithmetic-programs","title":"Generating arithmetic programs","text":""},{"location":"api/code_generation_api/#oraqle.compiler.instructions.ArithmeticProgram","title":"<code>ArithmeticProgram</code>","text":"<p>An ArithmeticProgram represents an ordered set of arithmetic operations that compute an arithmetic circuit.</p> <p>The easiest way to obtain an <code>ArithmeticProgram</code> of an <code>ArithmeticCircuit</code> is to call <code>ArithmeticCircuit.generate_program()</code>.</p>"},{"location":"api/code_generation_api/#oraqle.compiler.instructions.ArithmeticProgram.__init__","title":"<code>__init__(instructions, stack_size, gf)</code>","text":"<p>Initialize an <code>ArithmeticProgram</code> from a list of <code>instructions</code>.</p> <p>The user must specify an upper bound on the <code>stack_size</code> required.</p>"},{"location":"api/code_generation_api/#oraqle.compiler.instructions.ArithmeticProgram.execute","title":"<code>execute(inputs)</code>","text":"<p>Executes the arithmetic program on plaintext inputs without using encryption.</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If there were no outputs in this program.</p> </li> </ul> <p>Returns: The first output in this program.</p>"},{"location":"api/code_generation_api/#oraqle.compiler.instructions.ArithmeticProgram.generate_code","title":"<code>generate_code(decrypt_outputs)</code>","text":"<p>Generates HElib code for this program.</p> <p>If <code>decrypt_outputs</code> is true, then the generated code will decrypt the outputs at the end of the circuit.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The generated code as a string.</p> </li> </ul>"},{"location":"api/code_generation_api/#generating-code-for-helib","title":"Generating code for HElib","text":"<p>...</p>"},{"location":"api/nodes_api/","title":"Nodes API","text":"<p>Warning</p> <p>In this version of Oraqle, the API is still prone to changes. Paths and names can change between any version.</p>"},{"location":"api/nodes_api/#boolean-operations","title":"Boolean operations","text":"AND operation OR operation NEG operation"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And","title":"<code>And</code>","text":"<p>               Bases: <code>CommutativeUniqueReducibleNode</code></p> <p>Performs an AND operation over several operands. The user must ensure that the operands are Booleans.</p>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.__init__","title":"<code>__init__(operands, gf)</code>","text":"<p>Initialize a node with the given set as the operands. None of the operands can be a constant.</p>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.apply_function_to_operands","title":"<code>apply_function_to_operands(function)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.replace_operands_using_function","title":"<code>replace_operands_using_function(function)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.evaluate","title":"<code>evaluate(actual_inputs)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.clear_cache","title":"<code>clear_cache(already_cleared)</code>","text":"<p>Clears any cached values of the node and any of its operands.</p>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.to_graph","title":"<code>to_graph(graph_builder)</code>","text":"<p>Adds this node to the graph as well as its edges.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The identifier of this <code>Node</code> in the <code>DotFile</code>.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.__hash__","title":"<code>__hash__()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.is_equivalent","title":"<code>is_equivalent(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.eliminate_common_subexpressions","title":"<code>eliminate_common_subexpressions(terms)</code>","text":"<p>Eliminates duplicate subexpressions that are equivalent (as defined by a node's <code>__eq__</code> and <code>__hash__</code> method).</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A <code>Node</code> that must replace the previous expression.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.count_parents","title":"<code>count_parents()</code>","text":"<p>Counts the total number of nodes in this subcircuit.</p>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.reset_parent_count","title":"<code>reset_parent_count()</code>","text":"<p>Resets the cached number of nodes in this subcircuit to 0.</p>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.arithmetize","title":"<code>arithmetize(strategy)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.arithmetize_depth_aware","title":"<code>arithmetize_depth_aware(cost_of_squaring)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.to_arithmetic","title":"<code>to_arithmetic()</code>","text":"<p>Outputs this node's equivalent ArithmeticNode. Errors if this node does not have a direct arithmetic equivalent.</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If there is no direct arithmetic equivalent.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.add","title":"<code>add(other, flatten=True)</code>","text":"<p>Performs a summation between <code>self</code> and <code>other</code>, possibly flattening any sums.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>Sum</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.__add__","title":"<code>__add__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.__radd__","title":"<code>__radd__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.mul","title":"<code>mul(other, flatten=True)</code>","text":"<p>Performs a multiplication between <code>self</code> and <code>other</code>, possibly flattening any products.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>Product</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.__mul__","title":"<code>__mul__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.bool_or","title":"<code>bool_or(other, flatten=True)</code>","text":"<p>Performs an OR operation between <code>self</code> and <code>other</code>, possibly flattening the result into an OR operation between many operands.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>Or</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.__or__","title":"<code>__or__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.bool_and","title":"<code>bool_and(other, flatten=True)</code>","text":"<p>Performs an AND operation between <code>self</code> and <code>other</code>, possibly flattening the result into an AND operation between many operands.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>And</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.__and__","title":"<code>__and__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.__lt__","title":"<code>__lt__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.__gt__","title":"<code>__gt__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.__le__","title":"<code>__le__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.__ge__","title":"<code>__ge__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.__neg__","title":"<code>__neg__()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.__invert__","title":"<code>__invert__()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.__pow__","title":"<code>__pow__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.__sub__","title":"<code>__sub__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.__rsub__","title":"<code>__rsub__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.__eq__","title":"<code>__eq__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_and.And.and_flatten","title":"<code>and_flatten(other)</code>","text":"<p>Performs an AND operation with <code>other</code>, flattening the <code>And</code> node if either of the two is also an <code>And</code> and absorbing <code>Constant</code>s.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>An <code>And</code> node containing the flattened AND operation, or a <code>Constant</code> node.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or","title":"<code>Or</code>","text":"<p>               Bases: <code>CommutativeUniqueReducibleNode</code></p> <p>Performs an OR operation over several operands. The user must ensure that the operands are Booleans.</p>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.__init__","title":"<code>__init__(operands, gf)</code>","text":"<p>Initialize a node with the given set as the operands. None of the operands can be a constant.</p>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.apply_function_to_operands","title":"<code>apply_function_to_operands(function)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.replace_operands_using_function","title":"<code>replace_operands_using_function(function)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.evaluate","title":"<code>evaluate(actual_inputs)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.clear_cache","title":"<code>clear_cache(already_cleared)</code>","text":"<p>Clears any cached values of the node and any of its operands.</p>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.to_graph","title":"<code>to_graph(graph_builder)</code>","text":"<p>Adds this node to the graph as well as its edges.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The identifier of this <code>Node</code> in the <code>DotFile</code>.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.__hash__","title":"<code>__hash__()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.is_equivalent","title":"<code>is_equivalent(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.eliminate_common_subexpressions","title":"<code>eliminate_common_subexpressions(terms)</code>","text":"<p>Eliminates duplicate subexpressions that are equivalent (as defined by a node's <code>__eq__</code> and <code>__hash__</code> method).</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A <code>Node</code> that must replace the previous expression.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.count_parents","title":"<code>count_parents()</code>","text":"<p>Counts the total number of nodes in this subcircuit.</p>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.reset_parent_count","title":"<code>reset_parent_count()</code>","text":"<p>Resets the cached number of nodes in this subcircuit to 0.</p>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.arithmetize","title":"<code>arithmetize(strategy)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.arithmetize_depth_aware","title":"<code>arithmetize_depth_aware(cost_of_squaring)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.to_arithmetic","title":"<code>to_arithmetic()</code>","text":"<p>Outputs this node's equivalent ArithmeticNode. Errors if this node does not have a direct arithmetic equivalent.</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If there is no direct arithmetic equivalent.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.add","title":"<code>add(other, flatten=True)</code>","text":"<p>Performs a summation between <code>self</code> and <code>other</code>, possibly flattening any sums.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>Sum</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.__add__","title":"<code>__add__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.__radd__","title":"<code>__radd__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.mul","title":"<code>mul(other, flatten=True)</code>","text":"<p>Performs a multiplication between <code>self</code> and <code>other</code>, possibly flattening any products.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>Product</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.__mul__","title":"<code>__mul__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.bool_or","title":"<code>bool_or(other, flatten=True)</code>","text":"<p>Performs an OR operation between <code>self</code> and <code>other</code>, possibly flattening the result into an OR operation between many operands.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>Or</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.__or__","title":"<code>__or__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.bool_and","title":"<code>bool_and(other, flatten=True)</code>","text":"<p>Performs an AND operation between <code>self</code> and <code>other</code>, possibly flattening the result into an AND operation between many operands.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>And</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.__and__","title":"<code>__and__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.__lt__","title":"<code>__lt__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.__gt__","title":"<code>__gt__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.__le__","title":"<code>__le__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.__ge__","title":"<code>__ge__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.__neg__","title":"<code>__neg__()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.__invert__","title":"<code>__invert__()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.__pow__","title":"<code>__pow__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.__sub__","title":"<code>__sub__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.__rsub__","title":"<code>__rsub__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.__eq__","title":"<code>__eq__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_or.Or.or_flatten","title":"<code>or_flatten(other)</code>","text":"<p>Performs an OR operation with <code>other</code>, flattening the <code>Or</code> node if either of the two is also an <code>Or</code> and absorbing <code>Constant</code>s.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>An <code>Or</code> node containing the flattened OR operation, or a <code>Constant</code> node.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg","title":"<code>Neg</code>","text":"<p>               Bases: <code>UnivariateNode</code></p> <p>A node that negates a Boolean input.</p>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.__init__","title":"<code>__init__(node, gf)</code>","text":"<p>Initialize a univariate node.</p>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.apply_function_to_operands","title":"<code>apply_function_to_operands(function)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.replace_operands_using_function","title":"<code>replace_operands_using_function(function)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.evaluate","title":"<code>evaluate(actual_inputs)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.clear_cache","title":"<code>clear_cache(already_cleared)</code>","text":"<p>Clears any cached values of the node and any of its operands.</p>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.to_graph","title":"<code>to_graph(graph_builder)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.__hash__","title":"<code>__hash__()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.is_equivalent","title":"<code>is_equivalent(other)</code>","text":"<p>Check whether <code>self</code> is semantically equivalent to <code>other</code>.</p> <p>This function may have false negatives but it should never return false positives.</p> <pre><code>`True` if `self` is semantically equivalent to `other`, `False` if they are not or that they cannot be shown to be equivalent.\n</code></pre>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.eliminate_common_subexpressions","title":"<code>eliminate_common_subexpressions(terms)</code>","text":"<p>Eliminates duplicate subexpressions that are equivalent (as defined by a node's <code>__eq__</code> and <code>__hash__</code> method).</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A <code>Node</code> that must replace the previous expression.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.count_parents","title":"<code>count_parents()</code>","text":"<p>Counts the total number of nodes in this subcircuit.</p>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.reset_parent_count","title":"<code>reset_parent_count()</code>","text":"<p>Resets the cached number of nodes in this subcircuit to 0.</p>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.arithmetize","title":"<code>arithmetize(strategy)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.arithmetize_depth_aware","title":"<code>arithmetize_depth_aware(cost_of_squaring)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.to_arithmetic","title":"<code>to_arithmetic()</code>","text":"<p>Outputs this node's equivalent ArithmeticNode. Errors if this node does not have a direct arithmetic equivalent.</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If there is no direct arithmetic equivalent.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.add","title":"<code>add(other, flatten=True)</code>","text":"<p>Performs a summation between <code>self</code> and <code>other</code>, possibly flattening any sums.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>Sum</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.__add__","title":"<code>__add__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.__radd__","title":"<code>__radd__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.mul","title":"<code>mul(other, flatten=True)</code>","text":"<p>Performs a multiplication between <code>self</code> and <code>other</code>, possibly flattening any products.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>Product</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.__mul__","title":"<code>__mul__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.bool_or","title":"<code>bool_or(other, flatten=True)</code>","text":"<p>Performs an OR operation between <code>self</code> and <code>other</code>, possibly flattening the result into an OR operation between many operands.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>Or</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.__or__","title":"<code>__or__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.bool_and","title":"<code>bool_and(other, flatten=True)</code>","text":"<p>Performs an AND operation between <code>self</code> and <code>other</code>, possibly flattening the result into an AND operation between many operands.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>And</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.__and__","title":"<code>__and__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.__lt__","title":"<code>__lt__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.__gt__","title":"<code>__gt__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.__le__","title":"<code>__le__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.__ge__","title":"<code>__ge__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.__neg__","title":"<code>__neg__()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.__invert__","title":"<code>__invert__()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.__pow__","title":"<code>__pow__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.__sub__","title":"<code>__sub__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.__rsub__","title":"<code>__rsub__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.__eq__","title":"<code>__eq__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.operands","title":"<code>operands()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.set_operands","title":"<code>set_operands(operands)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.boolean.bool_neg.Neg.operation","title":"<code>operation(operands)</code>","text":""},{"location":"api/nodes_api/#arithmetic-operations","title":"Arithmetic operations","text":"<p>These operations are fundamental arithmetic operations, so they will stay the same when they are arithmetized.</p>"},{"location":"api/nodes_api/#high-level-arithmetic-operations","title":"High-level arithmetic operations","text":"Subtraction Exponentiation"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction","title":"<code>Subtraction</code>","text":"<p>               Bases: <code>NonCommutativeBinaryNode</code></p> <p>Represents a subtraction, which can be arithmetized using addition and constant-multiplication.</p>"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.__init__","title":"<code>__init__(left, right, gf)</code>","text":"<p>Initialize a Node that performs an operation between two operands that is not commutative.</p>"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.apply_function_to_operands","title":"<code>apply_function_to_operands(function)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.replace_operands_using_function","title":"<code>replace_operands_using_function(function)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.evaluate","title":"<code>evaluate(actual_inputs)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.clear_cache","title":"<code>clear_cache(already_cleared)</code>","text":"<p>Clears any cached values of the node and any of its operands.</p>"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.to_graph","title":"<code>to_graph(graph_builder)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.__hash__","title":"<code>__hash__()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.is_equivalent","title":"<code>is_equivalent(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.eliminate_common_subexpressions","title":"<code>eliminate_common_subexpressions(terms)</code>","text":"<p>Eliminates duplicate subexpressions that are equivalent (as defined by a node's <code>__eq__</code> and <code>__hash__</code> method).</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A <code>Node</code> that must replace the previous expression.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.count_parents","title":"<code>count_parents()</code>","text":"<p>Counts the total number of nodes in this subcircuit.</p>"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.reset_parent_count","title":"<code>reset_parent_count()</code>","text":"<p>Resets the cached number of nodes in this subcircuit to 0.</p>"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.arithmetize","title":"<code>arithmetize(strategy)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.arithmetize_depth_aware","title":"<code>arithmetize_depth_aware(cost_of_squaring)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.to_arithmetic","title":"<code>to_arithmetic()</code>","text":"<p>Outputs this node's equivalent ArithmeticNode. Errors if this node does not have a direct arithmetic equivalent.</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If there is no direct arithmetic equivalent.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.add","title":"<code>add(other, flatten=True)</code>","text":"<p>Performs a summation between <code>self</code> and <code>other</code>, possibly flattening any sums.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>Sum</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.__add__","title":"<code>__add__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.__radd__","title":"<code>__radd__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.mul","title":"<code>mul(other, flatten=True)</code>","text":"<p>Performs a multiplication between <code>self</code> and <code>other</code>, possibly flattening any products.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>Product</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.__mul__","title":"<code>__mul__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.bool_or","title":"<code>bool_or(other, flatten=True)</code>","text":"<p>Performs an OR operation between <code>self</code> and <code>other</code>, possibly flattening the result into an OR operation between many operands.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>Or</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.__or__","title":"<code>__or__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.bool_and","title":"<code>bool_and(other, flatten=True)</code>","text":"<p>Performs an AND operation between <code>self</code> and <code>other</code>, possibly flattening the result into an AND operation between many operands.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>And</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.__and__","title":"<code>__and__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.__lt__","title":"<code>__lt__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.__gt__","title":"<code>__gt__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.__le__","title":"<code>__le__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.__ge__","title":"<code>__ge__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.__neg__","title":"<code>__neg__()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.__invert__","title":"<code>__invert__()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.__pow__","title":"<code>__pow__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.__sub__","title":"<code>__sub__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.__rsub__","title":"<code>__rsub__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.__eq__","title":"<code>__eq__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.operands","title":"<code>operands()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.set_operands","title":"<code>set_operands(operands)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.subtraction.Subtraction.operation","title":"<code>operation(operands)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power","title":"<code>Power</code>","text":"<p>               Bases: <code>UnivariateNode</code></p> <p>Represents an exponentiation: x ** constant.</p>"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.apply_function_to_operands","title":"<code>apply_function_to_operands(function)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.replace_operands_using_function","title":"<code>replace_operands_using_function(function)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.evaluate","title":"<code>evaluate(actual_inputs)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.clear_cache","title":"<code>clear_cache(already_cleared)</code>","text":"<p>Clears any cached values of the node and any of its operands.</p>"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.to_graph","title":"<code>to_graph(graph_builder)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.__hash__","title":"<code>__hash__()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.is_equivalent","title":"<code>is_equivalent(other)</code>","text":"<p>Check whether <code>self</code> is semantically equivalent to <code>other</code>.</p> <p>This function may have false negatives but it should never return false positives.</p> <pre><code>`True` if `self` is semantically equivalent to `other`, `False` if they are not or that they cannot be shown to be equivalent.\n</code></pre>"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.eliminate_common_subexpressions","title":"<code>eliminate_common_subexpressions(terms)</code>","text":"<p>Eliminates duplicate subexpressions that are equivalent (as defined by a node's <code>__eq__</code> and <code>__hash__</code> method).</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A <code>Node</code> that must replace the previous expression.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.count_parents","title":"<code>count_parents()</code>","text":"<p>Counts the total number of nodes in this subcircuit.</p>"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.reset_parent_count","title":"<code>reset_parent_count()</code>","text":"<p>Resets the cached number of nodes in this subcircuit to 0.</p>"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.arithmetize","title":"<code>arithmetize(strategy)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.arithmetize_depth_aware","title":"<code>arithmetize_depth_aware(cost_of_squaring)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.to_arithmetic","title":"<code>to_arithmetic()</code>","text":"<p>Outputs this node's equivalent ArithmeticNode. Errors if this node does not have a direct arithmetic equivalent.</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If there is no direct arithmetic equivalent.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.add","title":"<code>add(other, flatten=True)</code>","text":"<p>Performs a summation between <code>self</code> and <code>other</code>, possibly flattening any sums.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>Sum</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.__add__","title":"<code>__add__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.__radd__","title":"<code>__radd__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.mul","title":"<code>mul(other, flatten=True)</code>","text":"<p>Performs a multiplication between <code>self</code> and <code>other</code>, possibly flattening any products.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>Product</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.__mul__","title":"<code>__mul__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.bool_or","title":"<code>bool_or(other, flatten=True)</code>","text":"<p>Performs an OR operation between <code>self</code> and <code>other</code>, possibly flattening the result into an OR operation between many operands.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>Or</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.__or__","title":"<code>__or__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.bool_and","title":"<code>bool_and(other, flatten=True)</code>","text":"<p>Performs an AND operation between <code>self</code> and <code>other</code>, possibly flattening the result into an AND operation between many operands.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>And</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.__and__","title":"<code>__and__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.__lt__","title":"<code>__lt__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.__gt__","title":"<code>__gt__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.__le__","title":"<code>__le__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.__ge__","title":"<code>__ge__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.__neg__","title":"<code>__neg__()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.__invert__","title":"<code>__invert__()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.__pow__","title":"<code>__pow__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.__sub__","title":"<code>__sub__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.__rsub__","title":"<code>__rsub__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.__eq__","title":"<code>__eq__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.operands","title":"<code>operands()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.set_operands","title":"<code>set_operands(operands)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.operation","title":"<code>operation(operands)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.arithmetic.exponentiation.Power.__init__","title":"<code>__init__(node, exponent, gf)</code>","text":"<p>Initialize a <code>Power</code> node that exponentiates <code>node</code> with <code>exponent</code>.</p>"},{"location":"api/nodes_api/#polynomial-evaluation","title":"Polynomial evaluation","text":"Univariate polynomial evaluation"},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly","title":"<code>UnivariatePoly</code>","text":"<p>               Bases: <code>UnivariateNode</code></p> <p>Evaluation of a univariate polynomial.</p>"},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.apply_function_to_operands","title":"<code>apply_function_to_operands(function)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.replace_operands_using_function","title":"<code>replace_operands_using_function(function)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.evaluate","title":"<code>evaluate(actual_inputs)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.clear_cache","title":"<code>clear_cache(already_cleared)</code>","text":"<p>Clears any cached values of the node and any of its operands.</p>"},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.to_graph","title":"<code>to_graph(graph_builder)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.__hash__","title":"<code>__hash__()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.is_equivalent","title":"<code>is_equivalent(other)</code>","text":"<p>Check whether <code>self</code> is semantically equivalent to <code>other</code>.</p> <p>This function may have false negatives but it should never return false positives.</p> <pre><code>`True` if `self` is semantically equivalent to `other`, `False` if they are not or that they cannot be shown to be equivalent.\n</code></pre>"},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.eliminate_common_subexpressions","title":"<code>eliminate_common_subexpressions(terms)</code>","text":"<p>Eliminates duplicate subexpressions that are equivalent (as defined by a node's <code>__eq__</code> and <code>__hash__</code> method).</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A <code>Node</code> that must replace the previous expression.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.count_parents","title":"<code>count_parents()</code>","text":"<p>Counts the total number of nodes in this subcircuit.</p>"},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.reset_parent_count","title":"<code>reset_parent_count()</code>","text":"<p>Resets the cached number of nodes in this subcircuit to 0.</p>"},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.arithmetize","title":"<code>arithmetize(strategy)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.arithmetize_depth_aware","title":"<code>arithmetize_depth_aware(cost_of_squaring)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.to_arithmetic","title":"<code>to_arithmetic()</code>","text":"<p>Outputs this node's equivalent ArithmeticNode. Errors if this node does not have a direct arithmetic equivalent.</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If there is no direct arithmetic equivalent.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.add","title":"<code>add(other, flatten=True)</code>","text":"<p>Performs a summation between <code>self</code> and <code>other</code>, possibly flattening any sums.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>Sum</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.__add__","title":"<code>__add__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.__radd__","title":"<code>__radd__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.mul","title":"<code>mul(other, flatten=True)</code>","text":"<p>Performs a multiplication between <code>self</code> and <code>other</code>, possibly flattening any products.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>Product</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.__mul__","title":"<code>__mul__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.bool_or","title":"<code>bool_or(other, flatten=True)</code>","text":"<p>Performs an OR operation between <code>self</code> and <code>other</code>, possibly flattening the result into an OR operation between many operands.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>Or</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.__or__","title":"<code>__or__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.bool_and","title":"<code>bool_and(other, flatten=True)</code>","text":"<p>Performs an AND operation between <code>self</code> and <code>other</code>, possibly flattening the result into an AND operation between many operands.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>And</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.__and__","title":"<code>__and__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.__lt__","title":"<code>__lt__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.__gt__","title":"<code>__gt__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.__le__","title":"<code>__le__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.__ge__","title":"<code>__ge__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.__neg__","title":"<code>__neg__()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.__invert__","title":"<code>__invert__()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.__pow__","title":"<code>__pow__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.__sub__","title":"<code>__sub__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.__rsub__","title":"<code>__rsub__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.__eq__","title":"<code>__eq__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.operands","title":"<code>operands()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.set_operands","title":"<code>set_operands(operands)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.operation","title":"<code>operation(operands)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.__init__","title":"<code>__init__(node, coefficients, gf)</code>","text":"<p>Initialize a univariate polynomial with the given coefficients from least to highest order.</p>"},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.from_function","title":"<code>from_function(node, gf, function)</code>  <code>classmethod</code>","text":"<p>Interpolate a univariate polynomial for the given function.</p>"},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.from_function--returns","title":"Returns:","text":"<p>A UnivariatePoly whose coefficients compute the <code>function</code> on all inputs.</p>"},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.arithmetize_custom","title":"<code>arithmetize_custom(strategy)</code>","text":"<p>Compute an arithmetization along with a dictionary of precomputed powers.</p>"},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.arithmetize_custom--returns","title":"Returns:","text":"<p>An arithmetization and a dictionary of previously computed powers.</p>"},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.arithmetize_depth_aware_custom","title":"<code>arithmetize_depth_aware_custom(cost_of_squaring)</code>","text":"<p>Compute a depth-aware arithmetization as well as a dictionary indexed by the depth of the nodes in the front. The dictionary stores precomputed powers.</p>"},{"location":"api/nodes_api/#oraqle.compiler.polynomials.univariate.UnivariatePoly.arithmetize_depth_aware_custom--returns","title":"Returns:","text":"<p>A CostParetoFront with the depth-aware arithmetization and a dictionary indexed by the depth of the nodes in the front, returning a dictionary with previously computed powers.</p>"},{"location":"api/nodes_api/#control-flow","title":"Control flow","text":"If-else statement"},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse","title":"<code>IfElse</code>","text":"<p>               Bases: <code>FixedNode</code></p> <p>A node representing an if-else clause.</p>"},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.apply_function_to_operands","title":"<code>apply_function_to_operands(function)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.replace_operands_using_function","title":"<code>replace_operands_using_function(function)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.evaluate","title":"<code>evaluate(actual_inputs)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.clear_cache","title":"<code>clear_cache(already_cleared)</code>","text":"<p>Clears any cached values of the node and any of its operands.</p>"},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.to_graph","title":"<code>to_graph(graph_builder)</code>","text":"<p>Adds this node to the graph as well as its edges.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The identifier of this <code>Node</code> in the <code>DotFile</code>.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.eliminate_common_subexpressions","title":"<code>eliminate_common_subexpressions(terms)</code>","text":"<p>Eliminates duplicate subexpressions that are equivalent (as defined by a node's <code>__eq__</code> and <code>__hash__</code> method).</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A <code>Node</code> that must replace the previous expression.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.count_parents","title":"<code>count_parents()</code>","text":"<p>Counts the total number of nodes in this subcircuit.</p>"},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.reset_parent_count","title":"<code>reset_parent_count()</code>","text":"<p>Resets the cached number of nodes in this subcircuit to 0.</p>"},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.arithmetize","title":"<code>arithmetize(strategy)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.arithmetize_depth_aware","title":"<code>arithmetize_depth_aware(cost_of_squaring)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.to_arithmetic","title":"<code>to_arithmetic()</code>","text":"<p>Outputs this node's equivalent ArithmeticNode. Errors if this node does not have a direct arithmetic equivalent.</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>If there is no direct arithmetic equivalent.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.add","title":"<code>add(other, flatten=True)</code>","text":"<p>Performs a summation between <code>self</code> and <code>other</code>, possibly flattening any sums.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>Sum</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.__add__","title":"<code>__add__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.__radd__","title":"<code>__radd__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.mul","title":"<code>mul(other, flatten=True)</code>","text":"<p>Performs a multiplication between <code>self</code> and <code>other</code>, possibly flattening any products.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>Product</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.__mul__","title":"<code>__mul__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.bool_or","title":"<code>bool_or(other, flatten=True)</code>","text":"<p>Performs an OR operation between <code>self</code> and <code>other</code>, possibly flattening the result into an OR operation between many operands.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>Or</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.__or__","title":"<code>__or__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.bool_and","title":"<code>bool_and(other, flatten=True)</code>","text":"<p>Performs an AND operation between <code>self</code> and <code>other</code>, possibly flattening the result into an AND operation between many operands.</p> <p>It is possible to disable flattening by setting <code>flatten=False</code>.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>A possibly flattened <code>And</code> node or a <code>Constant</code> representing self &amp; other.</p> </li> </ul>"},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.__and__","title":"<code>__and__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.__lt__","title":"<code>__lt__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.__gt__","title":"<code>__gt__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.__le__","title":"<code>__le__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.__ge__","title":"<code>__ge__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.__neg__","title":"<code>__neg__()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.__invert__","title":"<code>__invert__()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.__pow__","title":"<code>__pow__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.__sub__","title":"<code>__sub__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.__rsub__","title":"<code>__rsub__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.__eq__","title":"<code>__eq__(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.__init__","title":"<code>__init__(condition, positive, negative, gf)</code>","text":"<p>Initialize an if-else node: If condition evaluates to true, then it outputs positive, otherwise it outputs negative.</p>"},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.__hash__","title":"<code>__hash__()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.is_equivalent","title":"<code>is_equivalent(other)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.operands","title":"<code>operands()</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.set_operands","title":"<code>set_operands(operands)</code>","text":""},{"location":"api/nodes_api/#oraqle.compiler.control_flow.conditional.IfElse.operation","title":"<code>operation(operands)</code>","text":""},{"location":"api/pareto_fronts_api/","title":"Pareto fronts API","text":"<p>Warning</p> <p>In this version of Oraqle, the API is still prone to changes. Paths and names can change between any version.</p> <p>If you are using depth-aware arithmetization, you will find that the compiler does not output one arithmetic circuit. Instead, it outputs a Pareto front, which represents the best circuits that it could generate trading off two metrics: The multiplicative depth and the multiplicative size/cost. This page briefly explains the API for interfacing with these Pareto fronts.</p>"},{"location":"api/pareto_fronts_api/#the-abstract-base-class","title":"The abstract base class","text":"Abstract ParetoFront"},{"location":"api/pareto_fronts_api/#oraqle.compiler.nodes.abstract.ParetoFront","title":"<code>ParetoFront</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for ParetoFronts.</p> <p>One objective is to minimize the multiplicative depth, while the other objective is minimizing some value, such as the multiplicative size or cost.</p>"},{"location":"api/pareto_fronts_api/#oraqle.compiler.nodes.abstract.ParetoFront.__init__","title":"<code>__init__()</code>","text":"<p>Initialize an empty ParetoFront.</p>"},{"location":"api/pareto_fronts_api/#oraqle.compiler.nodes.abstract.ParetoFront.from_node","title":"<code>from_node(node, depth=None, value=None)</code>  <code>classmethod</code>","text":"<p>Initialize a <code>ParetoFront</code> with one node in it.</p> <p>Returns:</p> <ul> <li> <code>ParetoFront</code>           \u2013            <p>New <code>ParetoFront</code>.</p> </li> </ul>"},{"location":"api/pareto_fronts_api/#oraqle.compiler.nodes.abstract.ParetoFront.from_leaf","title":"<code>from_leaf(leaf)</code>  <code>classmethod</code>","text":"<p>Initialize a <code>ParetoFront</code> with one leaf node in it.</p> <p>Returns:</p> <ul> <li> <code>ParetoFront</code>           \u2013            <p>New <code>ParetoFront</code>.</p> </li> </ul>"},{"location":"api/pareto_fronts_api/#oraqle.compiler.nodes.abstract.ParetoFront.add","title":"<code>add(node, depth=None, value=None)</code>","text":"<p>Adds the given <code>Node</code> to the <code>ParetoFront</code> by computing its multiplicative depth and value.</p> <p>Alternatively, the user can supply an unchecked <code>depth</code> and <code>value</code> so that these values do not have to be (re)computed.</p> <p>Returns: <code>True</code> if and only if the node was inserted into the ParetoFront (so it was in some way better than the current <code>Nodes</code>).</p>"},{"location":"api/pareto_fronts_api/#oraqle.compiler.nodes.abstract.ParetoFront.add_leaf","title":"<code>add_leaf(leaf)</code>","text":"<p>Add a leaf node to this <code>ParetoFront</code>.</p>"},{"location":"api/pareto_fronts_api/#oraqle.compiler.nodes.abstract.ParetoFront.add_front","title":"<code>add_front(front)</code>","text":"<p>Add all elements from <code>front</code> to <code>self</code>.</p>"},{"location":"api/pareto_fronts_api/#oraqle.compiler.nodes.abstract.ParetoFront.__iter__","title":"<code>__iter__()</code>","text":""},{"location":"api/pareto_fronts_api/#oraqle.compiler.nodes.abstract.ParetoFront.get_smallest_at_depth","title":"<code>get_smallest_at_depth(max_depth)</code>","text":"<p>Returns the circuit with the smallest value that has at most depth <code>max_depth</code>.</p>"},{"location":"api/pareto_fronts_api/#oraqle.compiler.nodes.abstract.ParetoFront.is_empty","title":"<code>is_empty()</code>","text":"<p>Returns whether the front is empty.</p>"},{"location":"api/pareto_fronts_api/#oraqle.compiler.nodes.abstract.ParetoFront.get_lowest_value","title":"<code>get_lowest_value()</code>","text":"<p>Returns the value (size or cost) of the Node with the highest depth, and therefore the lowest value.</p>"},{"location":"api/pareto_fronts_api/#depth-size-and-depth-cost-fronts","title":"Depth-size and depth-cost fronts","text":""}]}